#* Catherine Breen
#* for Oikos submission

## data processing
library(astroFns)
library(sp)
library(lutz)
library(dplyr)
library(lubridate)
library(slider) ## sliding averages

## model develop
library(MuMIn)
library(statmod)
library(tweedie)
library(cplm)
library(lmtest)
library(sandwich)
library(mgcv)
# library(glmmTMB)
# library(lme4)


## viz packages
library(corrplot)
library(ggplot2)
# library(gridExtra)
# library(purrr)

# library(mgcv)
# library(Metrics)
# library(overlap)
# library(stringr)
# library(sf)

### data files ###
## field data, snow data, temperature data
fdata <- read.csv('/Users/catherinebreen/Dropbox/Chapter3/data/fdata_tdata_snowDensity_fromR2.csv')
senorge <- read.csv('/Users/catherinebreen/Dropbox/Chapter3/data/senorge_outputs_Jan1_May17-23.csv')
senorge_temp <- read.csv('/Users/catherinebreen/Dropbox/Chapter3/data/minmaxavg_temp_senorge.csv')

senorge_temp$temp.diff <- senorge_temp$max.temp.c - senorge_temp$min.temp.c

senorge_temp2 <- senorge_temp %>%
  arrange(loc, date1) %>%  # Ensure data is sorted
  group_by(loc) %>%  # Group by location
  mutate(avg.temp.c.prev = lag(avg.temp.c),
         avg.temp.c.prev3 = slide_mean(avg.temp.c, before = 3, after = -1, complete = TRUE),
         avg.temp.c.prev2 = slide_mean(avg.temp.c, before = 2, after = -1, complete = TRUE)) %>%
  ungroup()  %>%
  select(X, avg.temp.c.prev, avg.temp.c.prev3, avg.temp.c.prev2)

senorge_temp <- left_join(senorge_temp, senorge_temp2, by = 'X')

fdata$Date <- as.character(as.Date(fdata$Date, format = "%m/%d/%y"))
fdata$Hour <- as.character(fdata$Hour)
fdata$week <- week(fdata$Date)

## data constraints
# snow depth > 10 cm
# not actively snow
# day had to cross freezing
fdata <- fdata[fdata['SnwDpth']>=10,]
fdata <- fdata[fdata['Weather']!='Snow',]
fdata <- fdata[fdata$cross_freezing == 'Y',]

## functions to use later ##
## this function backtracks the difference between two suntimes accounting for the change in day length
## i.e., 6 suntime and 8 suntime have more hours between them depending on early or late season
spanFunc <- function(clockTime, Dates, Coords) {
  # Find sunset/sunrise times at location
  sr <- suntools::sunriset(Coords, Dates, direct="sunrise") * 2 * pi  # radians
  sr <- as.numeric(sr$day_frac)
  ss <- suntools::sunriset(Coords, Dates, direct="sunset") * 2 * pi
  ss <- as.numeric(ss$day_frac)
  # Which observations are 'day', get relevant values for day vs night
  day <- clockTime > sr & clockTime < ss
  startClock <- ifelse(day, sr, ss)  # either sunrise or sunset
  dayLength <- ss - sr
  span <- ifelse(day, dayLength, (2*pi) - dayLength)  # length of day or night
  return(span)
}

calculate_deviance_explained <- function(model) {
  # Obtain the deviance of the given model
  model_deviance <- deviance(model)
  null_model <- update(model, . ~ 1)
  null_deviance <- deviance(null_model)
  deviance_explained <- 1 - (model_deviance / null_deviance)
  # Print the R-squared value (deviance explained)
  print(deviance_explained)
  return(deviance_explained)
}


## additional data ##
## Norway's daily weather model from senorge.no; data coincides with field season
## more info on data here: https://github.com/metno/seNorge_docs/wiki
colnames(senorge)[2] <- 'Latitude'
colnames(senorge)[4] <- 'Date'
senorge <- senorge[,c('Latitude','snowdepth.mm', 'Date', 'SWE.mm')]
senorge['snowDensity.senorge'] <- (senorge$SWE.mm / senorge$snowdepth.mm) * 100 # (g/cm3)
head(senorge)

## senorge temperature outputs
colnames(senorge_temp)[2] <- 'Latitude'
colnames(senorge_temp)[5] <- 'Date'
senorge_temp <- senorge_temp[,c('Latitude','Date', 'max.temp.c','min.temp.c','temp.diff','avg.temp.c',
                                'avg.temp.c.prev','avg.temp.c.prev3','avg.temp.c.prev2', 'cross_0')]
head(senorge_temp)

data <- dplyr::left_join(fdata, senorge, by = c('Latitude','Date'), relationship="many-to-many")
data <-dplyr::left_join(data, senorge_temp, by = c('Latitude','Date'), relationship="many-to-many")

## categorical data columns ##
data$cnpyClass <- ifelse(data$CnpyCvr < 50, 0, 1)
data$season <- ifelse(data$Month <= 3, 0, 1)
data$hotcold <- ifelse(data$avg.temp.c >= 0, 'plus', 'minus')
data$hotcold3 <- ifelse(data$avg.temp.c.prev3 >= 0, 'plus', 'minus')
data$hotcold2 <- ifelse(data$avg.temp.c.prev2 >= 0, 'plus', 'minus')
data$doy <- yday(data$Date)
data$cloudy <- ifelse(data$CldCvr >= 50, 'cloudy','sunny')


### suntime
data$rads <- astroFns::hms2rad(data$Hour)
coords <- data[,c("Longitude", "Latitude")]
Coords_SPDF <- sp::SpatialPointsDataFrame(coords,
                                          proj4string = CRS("+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"),
                                          data = data)
data$timeZone <- lutz::tz_lookup_coords(lat=data$Latitude,
                                        lon = data$Longitude,
                                        warn = FALSE,
                                        method = "accurate")
# Function to concatenate two strings
concatenate_strings <- function(date, time) {
  return(paste(date, time))}
# Using mapply to apply the function to each corresponding pair of elements
data$datetime <- mapply(concatenate_strings, data$Date, data$Time)

data <- data %>%
  mutate(datetime = as.POSIXct(paste(Date, Time), tz = "Europe/Oslo"),
         julian_day = yday(datetime),
         sun.time = sunTime(rads, datetime, Coords_SPDF))


data <- data %>%
  mutate(across(c(avgsinkDp, Latitude, Longitude, Elevation..m., week,
                  Aspect..d., CnpyCvr, Hour, cam_tempN, cam_tempS,
                  AirTemp, SnwDpth, CldCvr), as.numeric),
         Month = as.integer(Month),
         doy = yday(as.Date(Date)))

## check correlation between our ground measurements and modeled air measurements
data <- data %>%
  group_by(Date) %>%
  mutate(avg.AirTemp = mean(AirTemp, na.rm = TRUE))
cor.test(data$avg.AirTemp, data$avg.temp.c) ## AirTemp and avg.temp.c are correlated

### what about snow density? ## it's not, but likely due to heterogeneity
cor.test(data$snowDensity.senorge, data$snwDnsty10cm)
cor.test(data$avg.temp.c, data$avg.temp.c.prev)
cor.test(data$avg.temp.c, data$avg.temp.c.prev3)
cor.test(data$avg.temp.c, data$avg.temp.c.prev2)
cor.test(data$avg.temp.c, data$temp.diff)
cor.test(data$avg.temp.c, data$week)

##### If need to save data ######
#saveRDS(data, file = "snow_hardness_covariates_df.rds")

## exploratory plots ##

temp <- data[data$doy != 30,]

plot1a <- ggplot(data[data$julian_day != 30,], aes(x = sun.time, y = avgsinkDp, group=cnpyClass, color =cnpyClass)) +
  geom_point(position = position_jitter(width = 0.2, height = 0.2), alpha = 0.5) +
  geom_smooth(method = "lm", formula = y ~ sin(x) + cos(x)) + #method = "lm", formula = y ~ sin(2 * pi * x/24), se = TRUE, color = "blue") +
  scale_x_continuous(breaks = c(0, pi/2, pi, 3*pi/2, 2*pi), labels = c("midnight", "sunrise", "noon", "sunset", "midnight")) +
  labs(title = 'all data with sin(x)+cos(x) fit',
       x = "Time", #sun time
       y = "Average Sink Depth (cm) ") + theme_bw()
plot1a
plot1a + facet_wrap(~season)
plot1a + facet_wrap(~hotcold)
plot1a + facet_wrap(~hotcold3)
plot1a + facet_wrap(~hotcold2)
plot1a + facet_wrap(~cloudy)


table(data$hotcold) ## most even breakdown
table(data$hotcold2)
table(data$hotcold3)
table(data$season)
table(data$cloudy)
table(data$week)

####################### START HERE ######################
#data <- readRDS('/Users/catherinebreen/Dropbox/Chapter3/snow_hardness_covariates_df.rds')

### Supp figure 3
data$visit <- reorder(data$visit, data$county)
data$visit_f = factor(data$visit, levels=c(1,7,11,13, 4, 8, 10, 12, 3, 5, 9))
# Create the plot with reordered facets
plot_allvisits <- ggplot(data, aes(x = sun.time, y = avgsinkDp, color=factor(cnpyClass), group = factor(cnpyClass))) +
  geom_line() +
  scale_x_continuous(breaks = c(0, pi/2, pi, 3*pi/2, 2*pi), labels = c("midnight", "sunrise", "noon", "sunset", "midnight")) +
  labs(x = "Sun Time", # sun time
       y = "Snow Hardness Index (cm)") +
  theme_bw() +
  scale_color_manual(values = c("0" = "blue", "1" = "darkgreen"), # Adjust colors as needed
                     labels = c("0" = "Open", "1" = "Closed")) + # Set custom labels
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1), # Rotate x-axis labels
    legend.title = element_blank(), # Remove legend title
    legend.position = c(0.9, 0.9) # Move legend to top right corner
  )
# Facet by reordered 'visit'
plot_allvisits + facet_wrap(~ visit_f)

### some meta statistics
avg <- mean(data$avgsinkDp)
stdev <- sd(data$avgsinkDp)

stats <- data %>%
  group_by(cnpyClass) %>%
  summarise(
    avg = mean(avgsinkDp, na.rm = TRUE),
    stdev = sd(avgsinkDp, na.rm = TRUE),
  )
print(stats)
###################

data_var_only <- na.omit(data[c('sun.time','CnpyCvr','snowDensity.senorge','Latitude', 'season', 'avg.temp.c.prev',
                                'avg.temp.c.prev3','avg.temp.c.prev2','avg.temp.c','temp.diff', 'doy','week', 'CldCvr')])
## should be equal
nrow(data_var_only) == nrow(data) # TRUE!
data_var_only <- as.data.frame(scale(data_var_only))
colnames(data_var_only) <- c('sun time', 'canopy cover',
                             'modeled density','Latitude','season','prev.avg.temp',
                             'prev3.avg.temp','prev2.avg.temp','avg.temp.c','temp.diff','doy','week','cldcvr')

### Supp figure 1
corrplot::corrplot(cor(data_var_only), tl.col = "black", method = "color",
         outline = T,
         addCoef.col = "black", number.digits = 2, type = 'lower', tl.srt = 45,  # Rotate the labels by 45 degrees
         cl.pos = 'b',
         col = colorRampPalette(c("darkred", "white","darkblue"))(100))

corr_filtered <- cor(data_var_only)
corr_filtered[abs(corr_filtered) <= 0.4] <- 0  # Set correlations below 0.4 to NA

# Plot the filtered correlation matrix
corrplot(corr_filtered, tl.col = "black", method = "color", outline = TRUE,
         order = "hclust", addCoef.col = "black", number.digits = 1,
         cl.pos = 'b', col = colorRampPalette(c("darkred", "white","midnightblue"))(100),
         type = "lower",
         tl.srt = 45)  # Rotate the labels by 45 degrees


### check distribution

shapiro.test(data$avgsinkDp) ## it is NOT normal
qqnorm(data$avgsinkDp)
qqline(data$avgsinkDp, col = "red")

truncated_dat <- data[data$avgsinkDp > 1,]
shapiro.test(truncated_dat$avgsinkDp) ## it is NOT normal
qqnorm(truncated_dat$avgsinkDp)
qqline(truncated_dat$avgsinkDp, col = "red")

### Supp figure 2
ggplot(truncated_dat, aes(x = avgsinkDp)) +
  geom_histogram(binwidth = 0.5, fill = "skyblue", color = "white", alpha = 0.7) +
  labs(
    x = "Sinking Depth from Tuna Can Penetrometer (cm)",
    y = "Frequency"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

###################### UNIVARIATE MODELS #####################
univariate_model<- glm((avgsinkDp) ~ cnpyClass, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.32

univariate_model<- glm((avgsinkDp) ~ CnpyCvr, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.22

univariate_model<- glm((avgsinkDp) ~ AirTemp, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.22

univariate_model<- glm((avgsinkDp) ~ cam_tempS, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.01

univariate_model<- glm((avgsinkDp) ~ cam_tempN, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.002

univariate_model<- glm((avgsinkDp) ~ avg.temp.c, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.07

univariate_model<- glm((avgsinkDp) ~ avg.temp.c.prev, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.06

univariate_model<- glm((avgsinkDp) ~ season, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.12

univariate_model<- glm((avgsinkDp) ~ doy, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.032

univariate_model<- glm((avgsinkDp) ~ week, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.028

univariate_model<- glm((avgsinkDp) ~ avg.temp.c.prev3, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.08

univariate_model<- glm((avgsinkDp) ~ avg.temp.c.prev2, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.09

univariate_model<- glm((avgsinkDp) ~ temp.diff, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.015

univariate_model<- glm((avgsinkDp) ~  snowDensity.senorge, data = data,  na.action = na.omit, family = tweedie(var.power=1.1, link.power=0))
summary(univariate_model)
calculate_deviance_explained(univariate_model) ## 0.027

###############################################################
###################### SNOW HARDNESS MODEL #####################

# model2_tweedie <- cpglm((avgsinkDp+0.1) ~ scale(sin(sun.time)) * scale(season) * scale(cnpyClass) + scale(cos(sun.time)) * scale(season) * scale(cnpyClass),
#                         data = play,  na.action = na.omit, family=tweedie(var.power=1.1,link.power=0))

#data_na.omit <- na.omit(data[c('avgsinkDp','sun.time','cnpyClass','season','AirTemp', 'snwdnsity10cm', 'snowDensity.senorge','avg.temp.c')])


data$cnpyClass_F <- as.factor(data$cnpyClass)
data$cnpyClass_F <- ifelse(data$cnpyClass == 1, 'closed', 'open')
data$season_F <- as.factor(data$season)
data$hotcold_F <- as.factor(data$hotcold)
data$cloudy_F <- as.factor(data$cloudy)

table(data$cloudy_F)
table(data$hotcold_F)
table(data$season_F)
table(data$cnpyClass_F)
table(data$week)
table(round(data$avg.temp.c,2))

nrow(data[data$avgsinkDp <= 2,])
nrow(data[data$avgsinkDp > 2,])


data_na.omit <- na.omit(data[c('avgsinkDp','sun.time',"Latitude",'cnpyClass','CnpyCvr', 'season','AirTemp', 'snwDnsty10cm',
                               'cam_tempN','cam_tempS','snowDensity.senorge','avg.temp.c',
                               'avg.temp.c.prev','avg.temp.c.prev3','avg.temp.c.prev2','temp.diff',
                               'hotcold','doy','week', 'CldCvr', 'cross_freezing','Weather','SnwDpth','cloudy')])
data_na.omit$cnpyClass_F <- as.factor(data_na.omit$cnpyClass)
data_na.omit$cnpyClass_F <- ifelse(data_na.omit$cnpyClass == 1, 'closed', 'open')
data_na.omit$season_F <- as.factor(data_na.omit$season)
data_na.omit$season_F <- ifelse(data_na.omit$season_F == 0, "early", "late")
data_na.omit$hotcold_F <- as.factor(data_na.omit$hotcold)


write.csv(data_na.omit,'/Users/catherinebreen/Dropbox/Chapter3/data/data_simp.csv')

plot(data$avg.temp.c, data$avgsinkDp)
plot(data$avg.temp.c.prev, data$avgsinkDp)
plot(data$avg.temp.c.prev2, data$avgsinkDp)
plot(data$avg.temp.c.prev3, data$avgsinkDp)
plot(data$temp.diff, data$avgsinkDp)
plot(data$doy, data$avgsinkDp)
plot(data$week, data$avgsinkDp)


model1 <-  gam((avgsinkDp) ~ (sin(sun.time))*season_F*cnpyClass_F +
                       (cos(sun.time))*season_F*cnpyClass_F +
                       scale(snowDensity.senorge)*season_F*cnpyClass_F,
                     data = data,  na.action = na.omit,
               family = Tweedie(p=1.1, link = power(0)))
summary(model1)
calculate_deviance_explained(model1)
AICc(model1)
plot(model1$residuals, model1$fitted.values)
model1 <- update(model1, na.action = na.fail)
dredge_results <- dredge(model1)
top_modelseason <- get.models(dredge_results, 1)[[1]]
summary(top_modelweek)
AICc(top_modelweek, model1)

model1_gaus <-  gam((avgsinkDp) ~ (sin(sun.time))*season_F*cnpyClass_F +
                 (cos(sun.time))*season_F*cnpyClass_F +
                 scale(snowDensity.senorge)*season_F*cnpyClass_F,
               data = data,  na.action = na.omit)
summary(model1_gaus)
calculate_deviance_explained(model1_gaus)
AICc(model1_gaus, model1)
plot(model1_gaus$residuals, model1_gaus$fitted.values)


model1c <-  gam((avgsinkDp) ~ (sin(sun.time))*season_F*cnpyClass_F +
                 (cos(sun.time))*season_F*cnpyClass_F +
                 scale(snowDensity.senorge),
               data = data,  na.action = na.omit,
               family = Tweedie(p=1.1, link = power(0)))
summary(model1c)
calculate_deviance_explained(model1c)
AICc(model1c)
AICc(model1, model1c)
plot(model1c$residuals, model1c$fitted.values)

model1z <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c)*cnpyClass_F +
                  (cos(sun.time))*scale(avg.temp.c)*cnpyClass_F +
                  scale(snowDensity.senorge)*scale(avg.temp.c)*cnpyClass_F,
                data = data,  na.action = na.omit,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1z)
calculate_deviance_explained(model1z)
AICc(model1z)
AICc(model1, model1z)
plot(model1z$residuals, model1z$fitted.values)

model1w <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c.prev)*cnpyClass_F +
                  (cos(sun.time))*scale(avg.temp.c.prev)*cnpyClass_F +
                  scale(snowDensity.senorge)*scale(avg.temp.c.prev)*cnpyClass_F,
                data = data,  na.action = na.omit,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1w)
calculate_deviance_explained(model1w)
AICc(model1w)
AICc(model1, model1w)
plot(model1w$residuals, model1w$fitted.values)

model1w <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c.prev3)*cnpyClass_F +
                  (cos(sun.time))*scale(avg.temp.c.prev3)*cnpyClass_F +
                  scale(snowDensity.senorge)*scale(avg.temp.c.prev3)*cnpyClass_F,
                data = data,  na.action = na.omit,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1w)
calculate_deviance_explained(model1w)
AICc(model1w)
AICc(model1, model1w)
plot(model1w$residuals, model1w$fitted.values)

cor.test(data$doy, data$avg.temp.c)
model1t <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                  (cos(sun.time))*cnpyClass_F +
                  scale(snowDensity.senorge) +
                 scale(doy)*scale(avg.temp.c)*cnpyClass_F,
                data = data,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1t)
calculate_deviance_explained(model1t)
AICc(model1t)
AICc(model1, model1t)
plot(model1t$residuals, model1t$fitted.values)


model1t_glm <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                  (cos(sun.time))*cnpyClass_F +
                  scale(snowDensity.senorge)*scale(avg.temp.c)*cnpyClass_F +
                  scale(doy)*scale(avg.temp.c)*cnpyClass_F,
                data = data,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1t_glm)
calculate_deviance_explained(model1t_glm)
AICc(model1t_glm)
AICc(model1, model1t_glm)
plot(model1t_glm$residuals, model1t_glm$fitted.values)
# Refit model with na.action = na.fail
model1t_glm <- update(model1t_glm, na.action = na.fail)
dredge_results <- dredge(model1t_glm)
top_model <- get.models(dredge_results, 1)[[1]]
plot(top_model$residuals, top_model$fitted.values)
summary(top_model)

inspect <- data[(data$avgsinkDp < 1) & (data$cnpyClass_F =='open'), ]

#saveRDS(top_model, "/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model.rds")


model1t_option <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                      (cos(sun.time))*cnpyClass_F +
                      scale(snowDensity.senorge) +
                      scale(doy)*scale(avg.temp.c)*cnpyClass_F,
                    data = data,
                    family = Tweedie(p=1.1, link = power(0)))
summary(model1t_option)
calculate_deviance_explained(model1t_option)
AICc(model1t_option)
AICc(model1, model1t_option)
plot(model1t_option$residuals, model1t_option$fitted.values)

model1t_option <- update(model1t_option, na.action = na.fail)
dredge_results <- dredge(model1t_option)
top_model2 <- get.models(dredge_results, 1)[[1]]
plot(top_model2$residuals, top_model2$fitted.values)
summary(top_model2)
AICc(top_model2, top_model)
saveRDS(top_model2, "/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model_nointerac_wdens.rds")

#saveRDS(top_model, "/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model.rds")
###############

model1_week <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(week)*cnpyClass_F +
                 (cos(sun.time))*scale(week)*cnpyClass_F +
                scale(snowDensity.senorge)*scale(week)*cnpyClass_F,
               data = data,  na.action = na.omit,
               family = Tweedie(p=1.1, link = power(0)))
summary(model1_week)
calculate_deviance_explained(model1_week)
AICc(model1_week,model1)
plot(model1_week$residuals, model1_week$fitted.values)
model1_week <- update(model1_week, na.action = na.fail)
dredge_results <- dredge(model1_week)
top_modelweek <- get.models(dredge_results, 1)[[1]]
summary(top_modelweek)
AICc(top_modelweek, model1)

model1_temp <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c)*cnpyClass_F +
                      (cos(sun.time))*scale(avg.temp.c)*cnpyClass_F +
                      scale(snowDensity.senorge)*scale(avg.temp.c)*cnpyClass_F,
                    data = data,  na.action = na.omit,
                    family = Tweedie(p=1.1, link = power(0)))
summary(model1_temp)
calculate_deviance_explained(model1_temp)
AICc(model1_temp,model1)
plot(model1_temp$residuals, model1_temp$fitted.values)
model1_week <- update(model1_temp, na.action = na.fail)
dredge_results <- dredge(model1_temp)
top_modeltemp <- get.models(dredge_results, 1)[[1]]
summary(top_modelweek)
AICc(top_modelweek, model1)


###########
library(pscl)
data$avgsinkDp_rd <-  round(data$avgsinkDp, 0)
hist(data$avgsinkDp_rd)

mod.hurdle <- hurdle((avgsinkDp_rd) ~ (sin(sun.time))*cnpyClass_F +
                       (cos(sun.time))*cnpyClass_F +
                       # scale(snowDensity.senorge)*cnpyClass_F +
                       scale(week)*scale(avg.temp.c)*cnpyClass_F, data = data, dist = "poisson",
                     zero.dist = "binomial")

# [(data$X != 41) | (data$X != 94) | (data$X != 109) ,]
#install.packages("distributions3")
#install.packages("topmodels", repos = "https://R-Forge.R-project.org")
AICc(mod.hurdle)
library(topmodels)
# same as this:
# mod.hurdle <- hurdle(visits ~ ., data = nmes, dist = "poisson",
summary(mod.hurdle)
calculate_deviance_explained(mod.hurdle)
rootogram(mod.hurdle, xlim = c(0,12), confint = FALSE, plot = "base")
plot(residuals(mod.hurdle))
# Assuming your model is 'model_hurdle'
residuals_model <- residuals(mod.hurdle)
outlier_index <- which(abs(residuals_model) > 3)
# View the row(s) with the outlier
outlier_data <- data[outlier_index, ]
print(outlier_data)

##
null_model <- glm(avgsinkDp_rd ~ 1, family = poisson(), data = data)  # Null model with intercept only
logLik_model <- logLik(mod.hurdle)  # Log-likelihood of fitted model
logLik_null <- logLik(null_model)  # Log-likelihood of null model

mcfadden_r2 <- 1 - (as.numeric(logLik_model) / as.numeric(logLik_null))
print(mcfadden_r2)


###############
model1t_tempdiff <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                           (cos(sun.time))*cnpyClass_F +
                           scale(snowDensity.senorge)*cnpyClass_F +
                           scale(doy)*scale(temp.diff)*cnpyClass_F,
                         data = data,
                         family = Tweedie(p=1.1, link = power(0)))
summary(model1t_tempdiff)
calculate_deviance_explained(model1t_tempdiff)
AICc(model1t_option)
AICc(model1, model1t_tempdiff)
plot(model1t_tempdiff$residuals, model1t_tempdiff$fitted.values)
model1t_tempdiff <- update(model1t_tempdiff, na.action = na.fail)
dredge_results <- dredge(model1t_tempdiff)
top_model3 <- get.models(dredge_results, 1)[[1]]
top_model3b <- get.models(dredge_results, 2)[[1]]
top_model3c <- get.models(dredge_results, 3)[[1]]
top_model3d <- get.models(dredge_results, 4)[[1]]
top_model3e <- get.models(dredge_results, 5)[[1]]
plot(top_model3$residuals, top_model3$fitted.values)
summary(top_model3)
AICc(top_model, top_model3, top_model3b, top_model3c, top_model3d, top_model3e)
saveRDS(top_model3, "/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model_nointerac_wdens_tempdiff.rds")


model1d <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                  (cos(sun.time))*cnpyClass_F +
                  (avg.temp.c)*cnpyClass_F +
                  scale(snowDensity.senorge)*cnpyClass_F,
                data = data,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1d)
calculate_deviance_explained(model1d)
AICc(model1d)
AICc(model1, model1d)
plot(model1d$residuals, model1d$fitted.values)

model1d_prev3 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(avg.temp.c.prev3) +
                  (cos(sun.time))*cnpyClass_F*scale(avg.temp.c.prev3) +
                  scale(snowDensity.senorge)*cnpyClass_F*scale(avg.temp.c.prev3),
                data = data,
                family = Tweedie(p=1.1, link = power(0)))
summary(model1d_prev3)
calculate_deviance_explained(model1d_prev3)
AICc(model1d_prev3)
AICc(model1, model1d_prev3)
plot(model1d_prev3$residuals, model1d_prev3$fitted.values)

model1d_prevg <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(avg.temp.c.prev) +
                         (cos(sun.time))*cnpyClass_F*scale(avg.temp.c.prev) +
                         scale(snowDensity.senorge)*cnpyClass_F*scale(avg.temp.c.prev),
                       data = data)
summary(model1d_prevg)
calculate_deviance_explained(model1d_prevg)
AICc(model1d_prevg)
AICc(model1, model1d_prevg)
plot(model1d_prevg$residuals, model1d_prevg$fitted.values)

model1d_prev3g <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(avg.temp.c.prev3) +
                        (cos(sun.time))*cnpyClass_F*scale(avg.temp.c.prev3) +
                       scale(snowDensity.senorge)*cnpyClass_F*scale(avg.temp.c.prev3),
                      data = data)
summary(model1d_prev3g)
calculate_deviance_explained(model1d_prev3g)
AICc(model1d_prev3g)
AICc(model1, model1d_prev3g)
plot(model1d_prev3g$residuals, model1d_prev3g$fitted.values)

model1d_prev2g <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(avg.temp.c.prev2) +
                         (cos(sun.time))*cnpyClass_F*scale(avg.temp.c.prev2),# +
                         #scale(snowDensity.senorge)*cnpyClass_F*scale(avg.temp.c.prev2),
                       data = data)
summary(model1d_prev2g)
calculate_deviance_explained(model1d_prev2g)
AICc(model1d_prev2g)
AICc(model1, model1d_prevg, model1d_prev3g, model1d_prev2g)
plot(model1d_prev3g$residuals, model1d_prev3g$fitted.values)

library(statmod)
tweedie_result <- tweedie.profile(avgsinkDp ~ (sin(sun.time))*cnpyClass_F +
                                    (cos(sun.time))*cnpyClass_F +
                                    (avg.temp.c)*cnpyClass_F +
                                    scale(snowDensity.senorge)*cnpyClass_F, data = data, p.vec = seq(1.1, 1.9, by = 0.1))
print(tweedie_result$p.max)


model1a <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F,
               data = data,  na.action = na.omit,
               family = Tweedie(p=1.1, link = power(0)))
summary(model1a)
calculate_deviance_explained(model1a)
AICc(model1, model1a)


model2 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                       (cos(sun.time))*cnpyClass_F +
                       scale(avg.temp.c)*cnpyClass_F +
                       scale(snowDensity.senorge)*cnpyClass_F,
                     data = data, na.action = na.omit,
               family = Tweedie(p=1.1, link = power(0))) ## [(data$Month != 4) & (data$Month != 5),]
summary(model2)
calculate_deviance_explained(model2)
AICc(model2)

model2glm <-  glm((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(avg.temp.c)*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F,
               data = data, na.action = na.omit,
               family=tweedie(var.power=1.5,link.power=0)) ## [(data$Month != 4) & (data$Month != 5),]
summary(model2glm)
calculate_deviance_explained(model2glm)
AICc(model2glm)

model3 <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                 (cos(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                 scale(snwDnsty10cm)*scale(avg.temp.c)*scale(CnpyCvr),
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model3)
AICc(model3)
AICc(model2, model3)


model3a <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                 (cos(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                 scale(snowDensity.senorge)*scale(avg.temp.c)*scale(CnpyCvr),
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

summary(model3a)
AICc(model3a)
AICc(model1, model3a)



model3b <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                  (cos(sun.time))*scale(avg.temp.c)*scale(CnpyCvr) +
                  scale(snowDensity.senorge)*scale(avg.temp.c)*scale(CnpyCvr),
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

summary(model3b)
#plot(model3b)
summary(model3b)
AICc(model3b)
AICc(model1, model3b)

### this one looks good ##
model4 <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(avg.temp.c.prev2)*cnpyClass_F +
                 (cos(sun.time))*scale(avg.temp.c.prev2)*cnpyClass_F +
                  scale(snowDensity.senorge)*scale(avg.temp.c.prev2)*cnpyClass_F, # +
                #scale(Latitude)*scale(avg.temp.c)*cnpyClass_F,
               data = data_na.omit, family=Tweedie(p=1.1, link = power(0)))
               #family = Tweedie(p=1.1, link = power(0)))
summary(model4)
AICc(model4)
AICc(model1, model4)

model5 <-  gam((avgsinkDp) ~ (sin(sun.time))*hotcold_F*cnpyClass_F +
                 (cos(sun.time))*hotcold_F*cnpyClass_F +
                 scale(snowDensity.senorge)*hotcold_F*cnpyClass_F, #+
                 #scale(Latitude)*hotcold_F*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model5)
AICc(model1, model5)

model6 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F+
                 #scale(Latitude)*cnpyClass_F+
                 scale(avg.temp.c)*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model6)

model6 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F+
                 #scale(Latitude)*cnpyClass_F+
                 scale(AirTemp)*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model6)

model7 <-  gam((avgsinkDp) ~ (sin(sun.time))*scale(doy)*cnpyClass_F +
                 (cos(sun.time))*scale(doy)*cnpyClass_F +
                 scale(snowDensity.senorge)*scale(doy)*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model7)

model8 <-  gam((avgsinkDp) ~ (sin(sun.time))*cloudy_F*cnpyClass_F +
                 (cos(sun.time))*cloudy_F*cnpyClass_F +
                 scale(snowDensity.senorge)*cloudy_F*cnpyClass_F +
                 scale(avg.temp.c)*cloudy_F*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model8)
AICc(model1, model8)

 model9 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F +
                 scale(avg.temp.c)*cnpyClass_F+
                 scale(CldCvr)*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))
summary(model9)
AICc(model1, model9)

model10 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                 (cos(sun.time))*cnpyClass_F +
                 scale(snowDensity.senorge)*cnpyClass_F +
                 scale(doy)*cnpyClass_F+
                 scale(CldCvr)*cnpyClass_F,
               data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

model11 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F +
                  (cos(sun.time))*cnpyClass_F +
                  scale(snowDensity.senorge)*cnpyClass_F +
                  scale(cam_tempN)*cnpyClass_F+
                  scale(CldCvr)*cnpyClass_F,
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

model12 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(AirTemp) +
                  (cos(sun.time))*cnpyClass_F*scale(AirTemp) +
                  scale(snowDensity.senorge)*cnpyClass_F* scale(AirTemp), # +
                  #scale(CldCvr)*cnpyClass_F* scale(cam_tempN),
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

model13 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*scale(avg.temp.c)*cloudy_F +
                  (cos(sun.time))*cnpyClass_F*scale(avg.temp.c)*cloudy_F +
                  scale(snowDensity.senorge)*cnpyClass_F*scale(avg.temp.c)*cloudy_F, # +
                #scale(CldCvr)*cnpyClass_F* scale(cam_tempN),
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

model14 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*cloudy_F +
                  (cos(sun.time))*cnpyClass_F*cloudy_F +
                  scale(snowDensity.senorge)*cnpyClass_F*cloudy_F, # +
                #scale(CldCvr)*cnpyClass_F* scale(cam_tempN),
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))

model15 <-  gam((avgsinkDp) ~ (sin(sun.time))*cnpyClass_F*cloudy_F +
                  (cos(sun.time))*cnpyClass_F*cloudy_F +
                  scale(snowDensity.senorge)*cnpyClass_F*cloudy_F +
                  scale(avg.temp.c)*cloudy_F, # +
                #scale(CldCvr)*cnpyClass_F* scale(cam_tempN),
                data = data, na.action = na.omit, family = Tweedie(p=1.1, link = power(0)))


model16 <-  gam((avgsinkDp) ~ (sin(sun.time)) +
                  (cos(sun.time)) +
                  scale(snowDensity.senorge) +
                  scale(avg.temp.c) +
                  cnpyClass_F,
                data = data,  na.action = na.omit,
                family = Tweedie(p=1.1, link = power(0)))

summary(model16)
AICc(model1, model16)

model17_interaction <- gam(avgsinkDp ~ s(sun.time, bs = "cc", by = cnpyClass) +
                             s(snowDensity.senorge, by=cnpyClass) +
                             s(doy, by = cnpyClass) +
                             s(AirTemp, by = cnpyClass) +
                             s(Hour, by=cnpyClass) +
                             cnpyClass,  # Include main effect of cnpyClass
                           data = data,
                           na.action = na.omit,
                           family = Tweedie(p = 1.1, link = power(0)))
summary(model17_interaction)


summary(model1)
gam.check(model1)
AIC(model1)
AICc(model1)
calculate_deviance_explained(model1)
lmtest::bptest(model1)
table(data$season)
plot(model1)
library(mgcv)
model_no_interaction <- gam(avgsinkDp ~ (sin(sun.time))*cnpyClass +
                              (cos(sun.time))*cnpyClass +
                              scale(snowDensity.senorge)*cnpyClass,
                            data = data,
                            family = Tweedie(p = 1.1, link = power(0)))

# Compare AIC values
AIC(model1, model_no_interaction)
data$residuals <- residuals(model1, type = "response")
ggplot(data, aes(x = season_F, y = residuals)) +
  geom_boxplot() +
  labs(title = "Residuals by Season", y = "Residuals") +
  theme_minimal()

data$fitted_values <- predict(model1, type = "response")
ggplot(data, aes(x = fitted_values, y = residuals)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Residuals vs Fitted Values", x = "Fitted Values", y = "Residuals") +
  theme_minimal()


summary(model2)
AICc(model2)
AIC(model2)
calculate_deviance_explained(model2)
lmtest::bptest(model2)

summary(model3)
AIC(model3)
calculate_deviance_explained(model3)
lmtest::bptest(model3)

summary(model3a)
AIC(model3a)
calculate_deviance_explained(model3a)
lmtest::bptest(model3a)

summary(model3b)
AIC(model3b)
calculate_deviance_explained(model3b)
lmtest::bptest(model3b)

summary(model4)
AIC(model4)
calculate_deviance_explained(model4)
lmtest::bptest(model4)
gam.check(model4)
plot(model4)

summary(model5)
AIC(model5)
calculate_deviance_explained(model5)
lmtest::bptest(model5)
table(data$hotcold_F)

summary(model6)
AIC(model6)
calculate_deviance_explained(model6)
lmtest::bptest(model6)

summary(model7)
AIC(model7)
calculate_deviance_explained(model7)
lmtest::bptest(model7)

summary(model8)
AIC(model8)
calculate_deviance_explained(model8)
lmtest::bptest(model8)

summary(model9)
AIC(model9)
calculate_deviance_explained(model9)
lmtest::bptest(model9)

summary(model10)
AIC(model10)
calculate_deviance_explained(model10)
lmtest::bptest(model10)

summary(model11)
AIC(model11)
calculate_deviance_explained(model11)
lmtest::bptest(model11)

summary(model12)
AIC(model12)
calculate_deviance_explained(model12)
lmtest::bptest(model12)

summary(model13)
AIC(model13)
calculate_deviance_explained(model13)
lmtest::bptest(model13)

summary(model14)
AIC(model14)
calculate_deviance_explained(model14)
lmtest::bptest(model14)

summary(model15)
AIC(model15)
calculate_deviance_explained(model15)
lmtest::bptest(model15)


############ check for overfitting: ######

gam.check(model1)

set.seed(123)
train_indices <- sample(1:nrow(data), size = 0.7 * nrow(data))
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]

model_train <- gam(avgsinkDp ~ (sin(sun.time)) * season_F * cnpyClass_F +
                     (cos(sun.time)) * season_F * cnpyClass_F +
                     scale(snowDensity.senorge) * season_F * cnpyClass_F,
                   data = train_data,
                   family = Tweedie(p = 1.1, link = power(0)))

train_predictions <- predict(model_train, newdata = train_data, type = "response")
train_rmse <- sqrt(mean((train_data$avgsinkDp - train_predictions)^2))
train_rmse

predictions <- predict(model_train, newdata = test_data, type = "response")
test_rmse <- sqrt(mean((test_data$avgsinkDp - predictions)^2))
test_rmse

#############





# Get log likelihood
## want to make
mega_model <- model4
log_likelihood <- logLik(mega_model)
# Get k (number of estimated parameters, including the intercept)
k <- attr(log_likelihood, "df")
# Print k
print(k)
options(na.action = "na.fail")

##### to get final model output ##
summary(model1d)
AICc(model1d)
dredge_results <- dredge(model1d)
print(subset(dredge_results))
sub <- subset(dredge_results, delta < 4)
sub <- as.data.frame(sub)
subset(dredge_results, delta < 4)[1]
head(dredge_results)


# To export as a CSV file
#write.csv(sub, "/Users/catherinebreen/Dropbox/Chapter3/data/dredge_table_LAT_TEMP.csv",)


model_gamGLM_TEMP <- gam((avgsinkDp) ~ cnpyClass_F + cos(sun.time) +
                              scale(avg.temp.c) +
                              scale(snowDensity.senorge) +
                              (sin(sun.time)) +
                              cnpyClass_F*scale(avg.temp.c) +
                              cnpyClass_F*scale(snowDensity.senorge),
                            data = data_na.omit,
                            family = Tweedie(p=1.1, link = power(0)))

model_GLM_TEMP <- glm((avgsinkDp) ~ cnpyClass_F + cos(sun.time) +
                           scale(avg.temp.c) +
                           scale(snowDensity.senorge) +
                           (sin(sun.time)) +
                           cnpyClass_F*scale(avg.temp.c) +
                           cnpyClass_F*scale(snowDensity.senorge),
                         data = data_na.omit,
                      family =  tweedie(var.power=1.1,
                                        link.power=0))
AICc(model1,model_gamGLM_TEMP, model_GLM_TEMP)

## use GAM to get AIC ###
model_GLM_TEMP <- glm((avgsinkDp) ~ cnpyClass_F + cos(sun.time) +
                              scale(avg.temp.c) + scale(Latitude) +
                              scale(snowDensity.senorge) +
                              (sin(sun.time)) +
                              cnpyClass_F*scale(avg.temp.c) +
                              cnpyClass_F*scale(Latitude) +
                              cnpyClass_F*scale(snowDensity.senorge) +
                              cos(sun.time)*scale(avg.temp.c) +
                              scale(avg.temp.c)*scale(snowDensity.senorge)+
                              scale(avg.temp.c)*sin(sun.time) ,
                            data = data_na.omit,
                            family =  tweedie(var.power=1.1,
                                              link.power=0))

AIC(model_GLM_TEMP) ## 1002.333; 1007.316


## MODEL DIAGNOSTICS
## look at pvalues
## they are probably inflated because we have heteroskedasticity

#3saveRDS(model_gamGLM_LATTEMP, '/Users/catherinebreen/Dropbox/Chapter3/models/bestModel_dredgegamtweedie_LAT_TEMP.rds')
saveRDS(model_GLM_TEMP, '/Users/catherinebreen/Dropbox/Chapter3/models/model_GLM_TEMP.rds')


### other models
best_model1gam_F <- gam((avgsinkDp) ~ cnpyClass_F + cos(sun.time) +
                        scale(snowDensity.senorge) + season_F + (sin(sun.time)) +
                          cnpyClass_F*cos(sun.time) +
                          cnpyClass_F*scale(snowDensity.senorge) +
                          cos(sun.time)*season_F +
                          sin(sun.time)*season_F ,
                      data = data_na.omit,
                      family = Tweedie(p=1.1, link = power(0)))
summary(best_model1gam_F)
plot(residuals(best_model1gam_F))
plot(fitted(best_model1gam_F), residuals(best_model1gam_F))
bp_model <- lm(residuals(best_model1gam_F)^2 ~ fitted(best_model1gam_F))
bptest(best_model1gam_F)
AIC(best_model1gam_F) ## 1014.209; other one is better
calculate_deviance_explained(best_model1gam_F)
qqnorm(resid(best_model1gam_F))



###########
### Now that we have picked the best model we are going to visualize it by predicting data
# Load necessary libraries
# Assuming 'data' is your original data frame and 'model' is already fitted as specified

# Create a sequence of sun.time values for prediction
sun_time_seq <- seq(0, 2*pi, length.out = 1000)
air.temp.seq <- seq(-7, 4, length.out = 20)
temp.diff.seq <- seq(2, 20, length.out = 20)
#avgtemp_seq <- seq(-12, 5, by=1, length.out = 10)

# Create a new data frame for predictions
pred_data <- expand.grid(
  sun.time = sun_time_seq,
  season_F = c('early', 'late'),
  cnpyClass_F = c('open', 'closed'),
  Latitude = c(61),
  avg.temp.c = air.temp.seq, #c(-1, 1),
  temp.diff = temp.diff.seq,
  doy = c(45, 105),
  hotcold_F = c('minus','plus'),
  snowDensity.senorge = 300

)

# Generate predicted values using the model for all combinations of season and cnpyClass
top_model <- readRDS("/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model.rds")
top_model_tempdiff <- readRDS('/Users/catherinebreen/Dropbox/Chapter3/r_outputs/avg_temp_doy_top_model_nointerac_wdens_tempdiff.rds')
model <- top_model_tempdiff #model5
  #model_gamGLM_LATTEMP #best_model1gam_F #model_gamGLM_LATTEMP

pred_data$predicted_hardness <- predict(model, newdata = pred_data, type = "response", se.fit = TRUE)$fit
#pred_data$predicted_hardness <- predict(best_model4, newdata = pred_data, type = "response", se.fit = TRUE)$fit
pred_data$se <- predict(model, newdata = pred_data[1,], type = "response", se.fit = TRUE)$se.fit

head(pred_data)

pred_data[(pred_data$predicted_hardness < 1) & (pred_data$cnpyClass_F == 'open'),]


################## PLOT ####################
data$cnpyClass_F <- ifelse(data$cnpyClass == 1, "closed", "open")
data$season_F <- ifelse(data$season == 0, "early", "late")

# Define custom tick positions and labels
tick_positions <- c(0, pi/2, pi, 3*pi/2, 2*pi)
tick_labels <- c("midnight", "sunrise", "noon", "sunset", "midnight")




# Plot for Early Season (season == 0)
colddays_plot <- ggplot(data = pred_data[(pred_data$temp.diff > 0) & (pred_data$doy > 70), ], aes(x = sun.time, y = predicted_hardness, color = factor(cnpyClass_F))) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), width = 0.1, alpha = 0.5, color = 'lightgrey') +  # Add error bars
 # geom_ribbon(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), alpha = 0.5, fill='grey', color = 'grey') +
  geom_point(
    data = data[data['temp.diff'] > 0,], #$season_F == 'early',],
    aes(x = sun.time, y = avgsinkDp, color = factor(cnpyClass_F)),
    alpha = 0.5, position='jitter') +
  labs(x = "", y = "Tuna Can Sinking Depth (cm)", title = "A)", color = "Canopy Class") +
  geom_vline(xintercept = 3*pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical line at 3*pi/2
  geom_vline(xintercept = pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical
  scale_color_manual(values = c("darkblue", "darkgreen"), labels = c("Open Canopy", "Closed Canopy")) +
  scale_x_continuous(breaks = tick_positions, labels = tick_labels) +
  theme_minimal() + theme(legend.position = 'none',
                          axis.text.x = element_text(size = 16, angle = 0, color = 'black'), # Rotate x-axis labels
                          axis.title.x = element_text(size = 16, color = 'black'),       # Increase x-axis title text size
                          axis.text.y = element_text(size =16, color = 'black'),
                          axis.title.y = element_text(size = 16, color = 'black'),
                          plot.title = element_text(size = 20),         # Increase plot title text size
                          plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm")
  ) + geom_line(size = 1) +
  ylim(-0.5,8)

colddays_plot






early_season_plot <- ggplot(data = pred_data[(pred_data$doy < 70) & (pred_data$avg.temp == 1), ], aes(x = sun.time, y = predicted_hardness, color = factor(cnpyClass_F))) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), width = 0.1, alpha = 0.5, color = 'lightgrey') +  # Add error bars
 # geom_ribbon(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), alpha = 0.5, fill='grey', color = 'grey') +
  geom_point(
    data = data[data['doy'] < 70,], #$season_F == 'early',],
    aes(x = sun.time, y = avgsinkDp, color = factor(cnpyClass_F)),
    alpha = 0.5, position='jitter') +
  labs(x = "", y = "Tuna Can Sinking Depth (cm)", title = "A)", color = "Canopy Class") +
  geom_vline(xintercept = 3*pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical line at 3*pi/2
  geom_vline(xintercept = pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical
  scale_color_manual(values = c("darkblue", "darkgreen"), labels = c("Open Canopy", "Closed Canopy")) +
  scale_x_continuous(breaks = tick_positions, labels = tick_labels) +
  theme_minimal() + theme(legend.position = 'none',
                          axis.text.x = element_text(size = 16, angle = 0, color = 'black'), # Rotate x-axis labels
                          axis.title.x = element_text(size = 16, color = 'black'),       # Increase x-axis title text size
                          axis.text.y = element_text(size =16, color = 'black'),
                          axis.title.y = element_text(size = 16, color = 'black'),
                          plot.title = element_text(size = 20),         # Increase plot title text size
                          plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm")
  ) + geom_line(size = 1) +
  ylim(-0.5,8)

early_season_plot


nrow(data[data['doy'] >= 68,])
nrow(data[data['doy'] < 68,])

# Plot for Late Season (season == 1)
late_season_plot <- ggplot(data = pred_data[(pred_data$doy >= 70) & (pred_data$temp.diff >= 12), ], aes(x = sun.time, y = predicted_hardness, color = factor(cnpyClass_F))) + # fill = 'grey') +   #aes(color = factor(cnpyClass))) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), width = 0.1, alpha = 0.5, color = 'lightgrey') +
  #geom_ribbon(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se), alpha = 0.5, fill='grey', color = 'grey') +
  geom_point(
    data = data[data['doy'] > 70,], aes(x = sun.time, y = avgsinkDp, color = factor(cnpyClass_F)),
    alpha = 0.5, position='jitter') +
  labs(x  = "", y = "", title = "B)", color = "Canopy Class") +
  geom_vline(xintercept = 3*pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical line at 3*pi/2
  geom_vline(xintercept = pi/2, linetype = "dashed", color = "darkgrey", linewidth=1) + # Add vertical
  scale_color_manual(values = c("darkgreen", "darkblue"), labels = c("Open Canopy", "Closed Canopy")) +
  scale_x_continuous(breaks = tick_positions, labels = tick_labels) +
  theme_minimal() + theme(
                           axis.text.x = element_text(size = 16, angle = 0, color = 'black'), # Rotate x-axis labels
                          axis.title.x = element_text(size = 16, color = 'black'),       # Increase x-axis title text size
                          axis.text.y = element_text(size = 16, color = 'black'),
                         # axis.title.y = element_text(size = 16, color = 'black'),
                          plot.title = element_text(size = 20),
                          axis.ticks.y = element_blank(),    # Turn off y-axis tick marks
                          # legend.position = c(0.80,0.75),
                          # legend.text = element_text(size =16),
                          legend.position = 'none',
    plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm")
  ) + #guides(color = guide_legend(title = NULL)) + # Remove legend title +
  geom_line(size = 1) + ylim(-0.5,8)

late_season_plot

# geom_errorbar()# Print the plots
grid.arrange(early_season_plot, late_season_plot, ncol = 2)




## why 300 density ??
mean(data$snowDensity.senorge, na.rm = TRUE)
sd(data$snowDensity.senorge, na.rm = TRUE)

dens_seq <- seq(200, 360, length.out = 1000)

# Create a new data frame for predictions
pred_data2 <- expand.grid(
  sun.time =  pi/2, #c(0,pi/2, pi, 3*pi/2),
  season_ = c('early', 'late'),
  cnpyClass_ = c('open', 'closed'),
  avg.temp.c = 2,
  snowDensity.senorge = dens_seq
)
pred_data2$predicted_hardness <- predict(best_model1gam_F, newdata = pred_data2, type = "response", se.fit = TRUE)$fit
pred_data2$se <- predict(best_model1gam_F, newdata = pred_data2[1,], type = "response", se.fit = TRUE)$se.fit


### c - f



saveRDS(model3, 'model_cpglm_tweedie.rds')

############
## alt c d e f
pred_data3 <- expand.grid(
  sun.time =  c(0,pi/2, pi, 3*pi/2),
  season_ = c('early', 'late'),
  cnpyClass_ = c('open', 'closed'),
  avg.temp.c = 2,
  snowDensity.senorge = dens_seq
)
pred_data3$predicted_hardness <- predict(best_model1gam_F, newdata = pred_data3, type = "response", se.fit = TRUE)$fit
pred_data3$se <- predict(best_model1gam_F, newdata = pred_data3[1,], type = "response", se.fit = TRUE)$se.fit

vir_vector <-c("#440154FF", "#39568CFF", '#1F968BFF','#73D055FF')
#vir_vector <-c("#404788FF", "#238A8DFF", '#55C667FF','#FDE725FF')


c2 <- ggplot(pred_data3[pred_data3$season_ == 'early' & pred_data3$cnpyClass_ == 'open', ],
             aes(x = snowDensity.senorge, y = predicted_hardness)) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se),
                width = 0.1, alpha = 0.25, color = 'lightgrey') +
  geom_point(aes(color = factor(sun.time))) +  # Categorical color scale
  labs(x = expression(paste("Snow Density (", kg/m^{3}, ")")),
       y = "Tuna Can Sinking Depth (cm)", title = "A)", color = "Canopy Class") +
  scale_color_manual(values = vir_vector,
                     labels = c("midnight", "sunrise", 'noon', 'sunset')) +
  theme_minimal() +
  theme(
    legend.position = 'none',
    axis.text.x = element_text(size = 16, angle = 0, color = 'black'),
    axis.title.x = element_text(size = 16, color = 'black'),
    axis.text.y = element_text(size = 16, color = 'black'),
    axis.title.y = element_text(size = 16, color = 'black'),
    plot.title = element_text(size = 20)
  ) +
  #ylim(-0.5, 9) +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(-1, 9)) +
  geom_point(data = data[data$season_ == 'early' & data$cnpyClass_ == 'open', ],
                aes(x = snowDensity.senorge, y = avgsinkDp, fill = sun.time), alpha = 0.5, shape = 21, stroke = 0, size=2) +
  scale_fill_gradientn(colors = vir_vector)
 # scale_fill_gradient(low = "#440154FF", high = "#73D055FF")  # Continuous fill scale for the second geom_point

c2

d2 <- ggplot(pred_data3[pred_data3$season_ == 'late' & pred_data3$cnpyClass_ == 'open', ],
             aes(x = snowDensity.senorge, y = predicted_hardness)) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se),
                width = 0.1, alpha = 0.25, color = 'lightgrey') +
  geom_point(aes(color = factor(sun.time))) +  # Categorical color scale
  labs(x = expression(paste("Snow Density (", kg/m^{3}, ")")),
       y = "Tuna Can Sinking Depth (cm)", title = "B)", color = "Canopy Class") +
  scale_color_manual(values = vir_vector,
                     labels = c("midnight", "sunrise", 'noon', 'sunset')) +
  theme_minimal() +
  theme(
    legend.position = 'none',
    axis.text.x = element_text(size = 16, angle = 0, color = 'black'),
    axis.title.x = element_text(size = 16, color = 'black'),
    axis.text.y = element_text(size = 16, color = 'black'),
    axis.title.y = element_text(size = 16, color = 'black'),
    plot.title = element_text(size = 20)
  ) +
  #ylim(-0.5, 9) +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(-1, 9)) +
  geom_point(data = data[data$season_ == 'late' & data$cnpyClass_ == 'open', ],
                aes(x = snowDensity.senorge, y = avgsinkDp, fill = sun.time), alpha = 0.5, shape = 21, stroke = 0, size=2) +
  scale_fill_gradientn(colors = vir_vector)  # Continuous fill scale for the second geom_point



e2 <- ggplot(pred_data3[pred_data3$season_ == 'early' & pred_data3$cnpyClass_ == 'closed', ],
             aes(x = snowDensity.senorge, y = predicted_hardness)) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se),
                width = 0.1, alpha = 0.25, color = 'lightgrey') +
  geom_point(aes(color = factor(sun.time))) +  # Categorical color scale
  labs(x = expression(paste("Snow Density (", kg/m^{3}, ")")),
       y = "Tuna Can Sinking Depth (cm)", title = "C)", color = "Canopy Class") +
  scale_color_manual(values = vir_vector,
                     labels = c("midnight", "sunrise", 'noon', 'sunset')) +
  theme_minimal() +
  theme(
    legend.position = 'none',
    axis.text.x = element_text(size = 16, angle = 0, color = 'black'),
    axis.title.x = element_text(size = 16, color = 'black'),
    axis.text.y = element_text(size = 16, color = 'black'),
    axis.title.y = element_text(size = 16, color = 'black'),
    plot.title = element_text(size = 20)
  ) +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(-1, 9)) +
  geom_point(data = data[data$season_ == 'early' & data$cnpyClass_ == 'closed', ],
                aes(x = snowDensity.senorge, y = avgsinkDp, fill = sun.time), alpha = 0.5, shape = 21, stroke = 0, size=2) +
  scale_fill_gradientn(colors = vir_vector)  # Continuous fill scale for the second geom_point


f2 <- ggplot(pred_data3[pred_data3$season_ == 'late' & pred_data3$cnpyClass_ == 'closed', ],
             aes(x = snowDensity.senorge, y = predicted_hardness)) +
  geom_errorbar(aes(ymin = predicted_hardness - se, ymax = predicted_hardness + se),
                width = 0.1, alpha = 0.25, color = 'lightgrey') +
  geom_point(aes(color = factor(sun.time))) +  # Categorical color scale
  labs(x = expression(paste("Snow Density (", kg/m^{3}, ")")),
       y = "Tuna Can Sinking Depth (cm)", title = "D)", color = "Sun Time") +
  scale_color_manual(values = vir_vector,
                     labels = c("midnight", "sunrise", 'noon', 'sunset')) +
  theme_minimal() +
  theme(
    legend.position = 'none',
    axis.text.x = element_text(size = 16, angle = 0, color = 'black'),
    axis.title.x = element_text(size = 16, color = 'black'),
    axis.text.y = element_text(size = 16, color = 'black'),
    axis.title.y = element_text(size = 16, color = 'black'),
    plot.title = element_text(size = 20)
  ) +
  #ylim(-0.5, 9) +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(-1, 9)) +
  #ylim(-0.75, 9) +
  geom_point(data = data[data$season_ == 'late' & data$cnpyClass_ == 'closed', ],
                aes(x = snowDensity.senorge, y = avgsinkDp, fill = sun.time), alpha = 0.5, shape = 21, stroke = 0, size=2) +
  scale_fill_gradientn(colors = vir_vector) +
  guides(color = guide_legend(title = NULL))

grid.arrange(c2, d2, e2, f2, ncol = 2)


grid.arrange(early_season_plot, late_season_plot, c2, d2, e2, f2, ncol = 2)
grid.arrange(early_season_plot, late_season_plot, ncol=2)

grid.arrange( e2, f2, ncol=2)
grid.arrange(early_season_plot, late_season_plot, c2, d2, ncol = 2)

###############################













